// All #key field values are unique Firebase-generated sortable keys. Field has length 20 symbols.
// #key field must be deleted before writing to backend

// Defines a generic type ObjMap that represents an object
// where the keys are strings and the values are of type T.
// T is a placeholder for any type, allowing this type to be reused
// with different value types across the application.
// import {CheckListItem} from './core/checklist/checklist.service';


// import {firestore} from 'firebase-admin';


// import FieldValue = firestore.FieldValue;
// import {Observable} from 'rxjs';
// import {Observable} from 'rxjs/Observable';

// import FieldValue = firebase.firestore.FieldValue;
// import {Observable} from 'rxjs';
//import * as firebase from 'firebase/app';
//import FieldValue = firebase.firestore.FieldValue;
// tslint:disable-next-line:import-blacklist
//import {Observable} from 'rxjs';

interface ObjMap<T> {
  [x: string]: T; // 'x' can be any string, and the corresponding value will be of type T
}

// The Record type represents a detailed structure of a record entity.
// This can be used to define records with various metadata and attributes
// related to problems, tasks, and project management.

// Type of the record, can be one of the following:
// - 'activeProblem': A problem that is still ongoing. Can be changed to 'closedProblem'. Should have field 'description',
// - 'closedProblem': A problem that has been resolved. Can be changed to 'activeProblem'. Should have field 'description',
// - 'workRecord': General work-related record. Should have field 'done'
// - 'goal': A goal-setting record. Should have field 'todo'
export type RecordType = 'activeProblem' | 'closedProblem' | 'workRecord' | 'goal' | 'todo' | 'ai' | 'problem';

export interface Record {
  $key: string; // Unique key for the record. When written back $key should be deleted. Generated by Firebase DB


  recordType: RecordType;

  // Reference to the parent record, if any, otherwise undefined. Only 'workRecord' can have it
  parentRecordRef: string | undefined;

  boards: ObjMap<Board> | undefined;
  boardLists: ObjMap<BoardList> | undefined;
  header: string | undefined;

  // Flag indicating if the problem is closed, or undefined if not yet determined.
  closed: boolean | undefined; // Depends on recordType if ends in 'Problem'

  // Metadata about the creator of the record:
  creatorKey: string; // Unique key for the creator.
  creatorGroup: string; // Group or department of the creator.
  creatorGroupName: string | undefined; // Group or department of the creator.
  creatorName: string; // Full name of the creator.
  creatorEmail: string | undefined; // Optional email of the creator.

  // Timestamps for record creation and last update.
  dateCreated: number; // Unix timestamp of when the record was created.
  lastUpdated: number; // Unix timestamp of the last update.

  // Information about the task, such as description and current progress.
  description: string | undefined; // Required if it is Problem. Not shown for Work Record
  done: string | undefined; // Required if it is Problem.
  todo: string | undefined; // Not shown for Work Record

  // Equipment-related metadata.
  // Keys represent locations hierarchy, root is always Facility
  eqL1Key: string; // Departments or any level 1 areas
  eqL2Key: string; // Line, area, building etc
  eqL3Key: string; // Equipment unit, room, small area etc
  eqL4Keys: [] | undefined; // Sub units. In development!

  // Edited workgroup list (if any).
  // User can select which work group should participate
  editedWgList: ObjMap<string> | undefined;

  // Sub-records associated with this record, if any.
  // They are important part of concept. First user adds record, then he or any other user can add comment or work record any time
  // if record type changes from open to closed then closed should be false and vice versa
  // Comments differ from work records in that copies of data are created and work records are displayed in reports for shift,
  // equipment/location etc.
  // There is no possibility to hidden removed already added data, data only added
  subRecords: ObjMap<SubRecord> | undefined;

  // When user for example adds checklist, action is recorded so they are shown as info in same timeline as subRecords,
  // they are merged and sorted by date
  actions: ObjMap<RecordAction> | undefined;

  // Trello card references related to this record (if applicable).
  trelloCards: ObjMap<any> | undefined;

  // Media attachments: images, files, and videos linked to this record.
  images: ObjMap<RecordImage> | undefined;
  files: ObjMap<RecordFile> | undefined;
  videos: ObjMap<RecordVideo> | undefined;

  // Plan-Do-Check-Act (PDCA) cycle status, TODO: update depends on checklist items checked or ont, but not well implemented yet
  pdcaStatus: 'pdcaStatusPlan' | 'pdcaStatusDo' | 'pdcaStatusCheck' | 'pdcaStatusAct' | 'pdcaStatusArchive' | undefined;

  // Priority level, better to leave undefined
  priority: 'high' | 'normal' | 'low' | undefined;

  // Project key associated with this record, if any.
  projectKey: string | undefined;

  // Boolean flag indicating if this record has a checklist. For now stored in firestore and works not optimal
  hasChecklist: boolean | undefined;

  // Keys of connected checklists, will be implemented in realtime DB
  checkLists: ObjMap<CheckListItem> | undefined;

  // Hash ID for the record, used for short links service.
  hashId: string | undefined;

  // Flags related to safety and incidents.
  nearMiss: boolean | undefined; // Indicates if the record is related to a near miss event.
  safety: string | undefined; // Optional safety-related info.
  safetyViolation: string | undefined; // Optional safety violation info.

  // Tags related to technical or health/safety aspects.
  tagType: 'tecTag' | 'hsTag' | undefined;
  tagInfo: TagInfo | undefined; // Optional additional information about tags.

  // Planning status, indicates if the task was planned or unplanned.
  planning: Planning | undefined;

  // Questionnaires and root cause analysis (RCA) associated with the record.
  questionnaire: Questionnaire | undefined;
  rca: Questionnaire | undefined;

  // A map of labels, where the key is the label and the value is a boolean indicating if it's applied.
  labels: ObjMap<boolean> | undefined;

  translations: ObjMap<Translation> | undefined;
  path: string;
}

export interface SubRecord {
  creatorKey: string; // Unique identifier for the user who created the sub-record.
  creatorGroup: string; // Group or department to which the creator belongs.
  creatorName: string; // Full name of the creator.
  dateCreated: number; // Unix timestamp indicating when the sub-record was created.
  planning: Planning | undefined; // Indicates whether this sub-record is planned or unplanned.
  recordType: string; // Type of the sub-record
  inReplyTo: string | undefined; // Previous sub-record in a thread
  done: string | undefined; // Details of what has been completed, if applicable.
  commentText: string | undefined; // Optional comment or text associated with the sub-record.
  stateChange: string | undefined; // Represents a change in the state of the parent record (e.g., "closed", "reopened").
  images: ObjMap<RecordImage> | undefined; // Map of images associated with the sub-record.
  files: ObjMap<RecordFile> | undefined; // Map of files attached to the sub-record.
  videos: ObjMap<RecordVideo> | undefined; // Map of videos linked to the sub-record.

  // Optional Root Cause Analysis (RCA) questionnaire
  rca: Questionnaire | undefined;
}


export interface User {
  graphData: {
    mail: string; // External system's email (e.g., Microsoft Graph).
  } | undefined;
  $key: string; // Unique user identifier.
  email: string; // User's email address.
  displayName: string; // User's display name.
}

export interface UsersMap {
  [x: string]: User;
}

export interface EquipmentItem {
  $key: string; // Unique key for the record, used to identify it.
  name: string; // Name of the equipment item.
  level: number; // Hierarchical level of the equipment (e.g., tier or depth in a structure).
  parentKey: string; // Key of the parent item, used to establish relationships between items.
}

export interface EquipmentMap {
  [x: string]: EquipmentItem;
}

export interface ImageData {
  size: {
    height: number;
    width: number;
  };
  url: string; // URL to the image resource.
  labels?: string[];
  description?: string;
}

export interface RecordImage {
  image: ImageData; // Full-size image data including dimensions and URL.
  thumbnail: ImageData; // Thumbnail image data, including dimensions and URL.
}

export interface Workgroup {
  color: string;
  colorName: string | undefined;
  journal: boolean | undefined;
  name: string;
  shortName: string | undefined;
}

export interface WorkgroupMap {
  [x: string]: Workgroup;
}

export interface Team {
  name: string;
  users: UsersMap;
}


export interface TeamsMap {
  [x: string]: Team;
}

export type TeamUsers = UsersMap;
export type UserTeams = TeamsMap;

export interface RecordAction {
  payload: any;
  type: string;
}


interface TagInfo {
  anomalies: { color: string; name: string }[];
  author: string;
  closedBy: string;
  number: number;
  type: string;
}

export type RecordFile = any;

export type RecordVideo = any;

export type AtomicUpdate = any;

export interface SpRequest {
  creator: {
    displayName: string;
    nameLocal: string;
    workgroup: string;
  };
  dateCreated: number;

  priority: string; // Obsolete
  priorityType: string;

  selectedEquipmentKey: string; // Obsolete
  eqL3Key: string;

  trelloStatus: string;
  status: string;
  description: string;
  // eslint-disable-next-line @typescript-eslint/ban-types
  positions: {}[];
}

export interface NotificationToken {
  userKey: string;
  token: string;
}

export type TimeConfig = {
  timeZone: string;
  shifts: {
    startH: number,
    title: string
  }[]
} | undefined;

export interface Questionnaire {
  type: string;
  questions: ObjMap<any>;
}


export interface PathItem {
  $key: string;
  name: string;
  types: any[];
}

// BoardList represents a column or list within a board.
export interface BoardList {
  key: string; // Unique identifier for the list
  name: string; // Display name of the list
  boardKey: string; // Reference to the board it belongs to
  cards: Card[]; // Array of cards in this list
  position: number; // Position of the list within the board
}

// Board represents the entire board, with multiple lists.
export interface Board {
  key: string; // Unique identifier for the board
  title: string; // Title of the board
  description?: string; // Optional description of the board
  lists: ObjMap<BoardList>; // All lists within the board
  background?: string; // Board background color or image
}

// Card represents the tasks or items inside a list.
export interface Card {
  key: string; // Unique identifier for the card
  boardKey: string; // Unique identifier for the board
  listKey: string; // Reference to the list it belongs to
  title: string; // Title of the card
  description?: string; // Optional description of the card
  position: number; // Position within the list
  color?: string; // Optional card color
  dueDate?: Date; // Optional due date for the card
  labels?: string[]; // Optional array of labels
  images?: ImageData[]; // Optional array of labels
  checkLists?: CheckListItem[]; // Optional array of labels
}


export interface CheckListItem {
  checked: boolean;
  order: number;
  text: string;
  creatorKey: string;
  creatorName: string;
  dateCreated: number;
  deleted?: boolean;
  lastUpdated?: number;
  updatedByKey?: string;
  updatedByName?: string;
  checkedDate?: number;
  checkedByKey?: string;
  checkedByName?: string;
  checkListKey?: string;
  due?: number;
  dueSetByKey?: string;
  records?: ObjMap<boolean>;
  dueSetByName?: string;
  responsible?: string;
  responsibleSetByKey?: string;
  responsibleSetByName?: string;
  facilityKey: string;
}

export interface CheckListInfo {
  totalCounter: number;
  checkedCounter: number;
}


export interface TreeItem {
  key: string;
  name: string;
  name_en?: string;
  parentKey: string;
  path: string;
  details?: any;
  // recordCount?: Observable<number>;
  // problemCount?: Observable<number>;
  // processCount?: Observable<number>;

  // constructor(obj: any) {
  //   this.key = obj.$key || obj.key;
  //   this.name = obj.name;
  //   this.parentKey = obj.parentKey;
  //   this.level = obj.level;
  //   this.details = obj.details;
  // }
}

export interface EquipmentItem extends TreeItem {
  records?: any[];
  details?: {
    types: string[];
    producer: string;
    producerType: string;
    producerSerial: string;
    productionYear: string;
    description: string;
    id: string;
    images: ImageData[];
    files: any[];
  };
}

export interface LocationItem extends TreeItem {
  // Details about the location/equipment item
  details?: {
    // Description of the equipment
    description?: string;

    // Unique identifier for the equipment
    hashId?: string;

    // Files andImages associated with the equipment
    images?: ImageData[];
    files?: any[];


    // Producer data
    producer?: string;
    producerSerial?: string;
    producerType?: string;
    productionYear?: string;

    // Types associated with the equipment. Key must correspond to locationTypes
    types: string[];
    translation?: Translation;
  };
}

export type Planning = 'planned' | 'unplanned';

export interface DraftInfo {
  description?: string;
  done?: string;
  todo?: string;
  aiLocation?: string;
  aiText?: string;
  recordType: RecordType;
  locationKey?: string;
  safety?: boolean;
  quality?: boolean;
  qualityAnomalies?: { [key: string]: Boolean };
  planning?: Planning;
}

// Utility function to remove empty strings from a DraftInfo object
export function cleanDraftInfo(draft: DraftInfo): DraftInfo {
  const cleanedDraft = {...draft};

  // Iterate over the object properties and remove any empty strings
  Object.keys(cleanedDraft).forEach((key) => {
    if (!cleanedDraft[key as keyof DraftInfo] || cleanedDraft[key as keyof DraftInfo] === 'undefined') {
      delete cleanedDraft[key as keyof DraftInfo];
    }
  });

  return cleanedDraft as DraftInfo;
}

interface Translation {
  original: string;
  detectedLanguage: string;
  translations: ObjMap<string>;
}

// bg color for banner: rgb(26 128 98)
